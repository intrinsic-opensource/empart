#!/usr/bin/env python3
# Copyright 2025 Intrinsic Innovation LLC

"""
convert_e2e_log.py

Converts a console-based [E2E] interaction log into a fully executable
**Playwright + pytest** test script. The input log is expected to be
generated by an instrumented web application that prints structured
E2E event lines to the console.

Main Features:
- Parses raw console logs into structured interaction tokens (clicks, drags, keys, stats, etc.)
- Compresses low-level pointer sequences into high-level actions (e.g., drag gestures)
- Generates a deterministic pytest test case that replays the exact user interactions
- Adds assertions for dynamic UI behavior, such as stats updates, RTF logs, and console events
- Supports both navigation and simulation of mouse, keyboard, and DOM actions

Input:
    A text file containing an [E2E] log with structured console outputs.

Output:
    Prints a Playwright-compatible pytest test function to stdout.

Usage:
    1. Run your web application with E2E logging enabled. (https://localhost:5004/?e2e)
    2. Capture the console output to a file by interacting with the tool and clicking save e2e output
    3. Paste into a file named `recording.log`.
    3. $ python convert_e2e_log.py recording.log > test_example.py

"""

from pathlib import Path
from textwrap import indent
import re
import sys

# ──────────────────────────────── REGEXES ────────────────────────────────

LOG_LINE = re.compile(
    r"""
    \[E2E\]\s+
    (?P<kind>wheel|pointerdown|pointerup|pointermove|button\sclick|keydown|keyup)
    (?:\s+(?P<button>LMB|MMB|RMB))?
    (?:\s+(?P<extra>[A-Za-z_-]+))?
    (?:\s+\((?P<px>[\d.]+),\s*(?P<py>[\d.]+)\)
        (?:\s+→\s+(?P<pct_x>[\d.]+)%,\s*(?P<pct_y>[\d.]+)% )?
    )?
    (?:\s+\(deltaY=(?P<delta>-?[\d.]+)\))?
    (?:\s+(?:→\s*)?"(?P<label>[^"]+)")?
    """,
    re.VERBOSE,
)

VIEWPORT_LINE = re.compile(r"\[E2E\]\s+viewport\s+(?P<w>[\d.]+)\s+(?P<h>[\d.]+)")
STATS_LINE = re.compile(
    r"\[E2E\]\s+New stats → Vertices: (?P<verts>\d+), Faces: (?P<faces>\d+), Hulls: (?P<hulls>\d+)"
)
RTF_LINE = re.compile(r"\[E2E\]\s+rtf: (?P<rtf>[\d.]+)")
HULL_LINE = re.compile(
    r"\[E2E\]\s+(?P<action>Selected|Deselected)\s+hull → (?P<hull>[\w\-]+)"
)
PROCERR_LINE = re.compile(r"\[E2E\]\s+Process Error completed in\s+(?P<ms>\d+)\s+ms")
# ──────────────────────────────── PARSER ────────────────────────────────


def parse(lines):
    """
    Parses structured [E2E] console log lines into semantic interaction tokens.

    Each line is matched against multiple known E2E log formats (e.g., viewport size,
    mouse events, UI clicks, keyboard input, and console stats). Recognized patterns
    are converted into structured tuples representing actions to be replayed or verified.

    Ags:
        lines (Iterable[str]): Lines from an E2E log file (one action per line).

    Returns:
        Tuples representing actions:
            - ("viewport", width, height)
            - ("stats", vertices, faces, hulls)
            - ("rtf", value)
            - ("hull", action, hull_id)
            - ("proc_err", ms)
            - ("wheel", delta[, x, y])
            - ("pointerdown" or "pointerup", button, x, y)
            - ("pointermove", x, y)
            - ("click", label)
            - ("keydown", key)
    """
    for ln in lines:
        if m := VIEWPORT_LINE.search(ln):
            yield ("viewport", int(round(float(m["w"]))), int(round(float(m["h"]))))
            continue
        if m := STATS_LINE.search(ln):
            yield ("stats", int(m["verts"]), int(m["faces"]), int(m["hulls"]))
            continue
        if m := RTF_LINE.search(ln):
            yield ("rtf", float(m["rtf"]))
            continue
        if m := HULL_LINE.search(ln):
            yield ("hull", m["action"], m["hull"])
            continue
        if m := PROCERR_LINE.search(ln):
            yield ("proc_err", int(m["ms"]))  # ms is optional for the assert
            continue
        if not (m := LOG_LINE.search(ln)):
            continue
        k = m.groupdict()
        kind = k["kind"]

        if kind == "wheel" and k["delta"] is not None:
            delta = int(float(k["delta"]))
            if k["px"] and k["py"]:
                yield ("wheel", delta, float(k["px"]), float(k["py"]))
            else:
                yield ("wheel", delta)
            continue

        if kind in ("pointerdown", "pointerup") and k["px"] and k["py"]:
            yield (kind, k["button"], float(k["px"]), float(k["py"]))
            continue

        if kind == "pointermove" and k["px"] and k["py"]:
            yield ("pointermove", float(k["px"]), float(k["py"]))
            continue

        if kind == "button click" and k["label"]:
            yield ("click", k["label"])
            continue

        if kind in ("keydown", "keyup") and k["label"] and kind == "keydown":
            yield ("keydown", k["label"])


def strip_trailing_copy(actions):
    """Drop the “Copy E2E log” click the UI appends at the very end."""
    return (
        actions[:-1]
        if actions and actions[-1] == ("click", "Copy E2E log")
        else actions
    )


def compress_moves(actions, hover_stride=20, drag_stride=20.0):
    """
    Optimizes a sequence of pointer actions by compressing drags and thinning out hover moves.

    This function performs two key optimizations:
    1. Detects "pointerdown → pointermove* → pointerup" sequences and compresses them
       into a single ("drag", sx, sy, ex, ey, steps) token, while retaining the original
       down and up events.
    2. Outside of drag sequences, filters "pointermove" events to retain only those
       that are at least `hover_stride` pixels apart to reduce noise from frequent hovering.

    Args:
        actions (List[Tuple]): A list of parsed input actions, typically from `parse()`.
        hover_stride (int): Minimum pixel distance between pointermove events to retain them (default: 20).
        drag_stride (float): Pixel stride used to compute step count during drag compression (default: 20.0).

    Returns:
        List[Tuple]: A new list of actions with optimized structure for replay.
    """
    out, i, last_hover = [], 0, None

    def distance(a, b):
        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5

    while i < len(actions):
        kind = actions[i][0]

        # ── drag sequence ────────────────────────────────────────────────
        if kind == "pointerdown":
            down = actions[i]
            i += 1
            moves = []
            while i < len(actions) and actions[i][0] == "pointermove":
                moves.append(actions[i])
                i += 1
            up = (
                actions[i]
                if i < len(actions) and actions[i][0] == "pointerup"
                else None
            )
            if up:
                i += 1

            if moves and up:
                sx, sy = down[2], down[3]
                ex, ey = up[2], up[3]
                steps = max(2, int(distance((sx, sy), (ex, ey)) // drag_stride))
                out.extend([down, ("drag", sx, sy, ex, ey, steps), up])
            else:
                # not really a drag → keep verbatim
                out.extend([down] + moves + ([up] if up else []))
            last_hover = None  # reset hover tracker
            continue

        # ── hover move thinning ─────────────────────────────────────────
        if kind == "pointermove":
            _, x, y = actions[i]
            if last_hover is None or distance((x, y), last_hover) >= hover_stride:
                out.append(actions[i])
                last_hover = (x, y)
            i += 1
            continue

        # ── anything else ───────────────────────────────────────────────
        out.append(actions[i])
        i += 1

    return out


# ───────────────────────────── CODE GENERATOR ───────────────────────────
def gen_pytest(actions, port: int = 5004) -> str:
    """
    Converts a list of parsed E2E interaction tokens into a complete Playwright + pytest script.

    The generated test simulates user input actions (mouse movements, clicks, drags, keyboard presses),
    verifies console logs, and performs DOM assertions based on expected behavior observed in the original log.
    It also supports structured logging, viewport setup, and validation of dynamic application state.

    Args:
        actions (List[Tuple]): A list of structured action tokens from `parse()` and `compress_moves()`.
        port (int): Port number for the local server where the app is hosted (default: 5004).

    Return:
        str: A string containing a full Python test function compatible with pytest and Playwright.
             Includes setup, action replay, and verification/assert statements.
    """
    IND = " " * 4
    out: list[str] = [
        "import pytest",
        "from playwright.sync_api import Page",
        "",
        "",
        "def test_recording(page: Page):",
    ]

    skip_stats = 0  # how many subsequent stats lines to ignore

    # viewport
    if vp := next((a for a in actions if a[0] == "viewport"), None):
        _, w, h = vp
        out.append(
            indent(f"page.set_viewport_size({{'width': {w}, 'height': {h}}})", IND)
        )

    # console capture
    out.append(indent("logs: list[str] = []", IND))
    out.append(indent('page.on("console", lambda m: logs.append(m.text))', IND))
    out.append(indent('page.on("console", lambda m: print("[console]", m.text))', IND))

    # navigate
    out.append(
        indent(
            f'page.goto("http://localhost:{port}/?e2e", wait_until="domcontentloaded")',
            IND,
        )
    )
    out.append(indent("page.wait_for_timeout(3000)  # initial settle", IND))

    # action replay
    for act in actions:
        kind = act[0]

        if kind == "viewport":
            continue

        # ──────────────────────── wheel ──────────────────────────────
        if kind == "wheel":
            if len(act) == 4:
                _, delta, x, y = act
                out.append(indent(f"page.mouse.move({x:.3f}, {y:.3f})", IND))
            else:
                _, delta = act
            out.append(indent(f"page.mouse.wheel(0, {delta})", IND))
            continue

        # ─────────────────────── pointer-move ────────────────────────
        if kind == "pointermove":
            _, x, y = act
            out.append(indent(f"page.mouse.move({x:.3f}, {y:.3f})", IND))
            continue

        # ───────────────────────── drag ──────────────────────────────
        if kind == "drag":
            _, sx, sy, ex, ey, steps = act
            out.append(indent(f"page.mouse.move({sx:.1f}, {sy:.1f})", IND))
            out.append(indent("page.mouse.down()", IND))
            out.append(
                indent(f"page.mouse.move({ex:.1f}, {ey:.1f}, steps={steps})", IND)
            )
            out.append(indent("page.mouse.up()", IND))
            continue

        # ─────────────── pointer-down → automatic click ───────────────
        if kind == "pointerdown":
            _, btn, x, y = act
            out.append(indent(f"page.mouse.move({x:.3f}, {y:.3f})", IND))

            btn_map = {"LMB": "left", "MMB": "middle", "RMB": "right"}
            arg = "" if btn == "LMB" else f"button='{btn_map[btn]}'"

            # mouse down then immediately up
            if arg:
                out.append(indent(f"page.mouse.down({arg})", IND))
                out.append(indent(f"page.mouse.up({arg})", IND))
            else:
                out.append(indent("page.mouse.down()", IND))
                out.append(indent("page.mouse.up()", IND))

            continue

        # ───────────────────── UI button click ──────────────────────
        if kind == "click":
            label = act[1]
            if label == "merge-hulls-btn":
                out.append(indent("prev_count = len(logs)", IND))
                out.append(indent(f'page.get_by_test_id("{label}").click()', IND))
                out.append(indent("page.wait_for_timeout(500)", IND))
                out.append(indent("new_logs = logs[prev_count:]", IND))
                out.append(
                    indent(
                        "stats_msgs = [m for m in new_logs if 'New stats →' in m]", IND
                    )
                )
                out.append(
                    indent(
                        'assert len(stats_msgs) >= 2, f"Expected ≥2 stats logs, got {len(stats_msgs)}"',
                        IND,
                    )
                )
                skip_stats = 2
            else:
                out.append(indent(f'page.get_by_test_id("{label}").click()', IND))
            continue

        # ─────────────────────── key-down ────────────────────────────
        if kind == "keydown":
            out.append(indent(f'page.keyboard.press("{act[1]}")', IND))
            continue

        # ───────────────── console “stats” check ─────────────────────
        if kind == "stats":
            if skip_stats:
                skip_stats -= 1
                continue

            _, v, f, h = act
            # patt = f"New stats → Vertices: {v}, Faces: {f}, Hulls: {h}"
            patt = f"Hulls: {h}"
            out.append(indent(f'if any("{patt}" in t for t in logs):', IND))
            out.append(indent("    pass", IND * 2))

            out.append(indent("else:", IND))
            out.append(
                indent(
                    f'    page.wait_for_event("console", lambda m: "{patt}" in m.text, timeout=100_000)',
                    IND,
                )
            )
            # one final assert for readability
            out.append(indent(f'assert any("{patt}" in t for t in logs)', IND))
            continue

        # ───────────────── console “rtf” check ───────────────────────
        if kind == "rtf":
            _, r = act
            patt = f"rtf: {r}"
            out.append(
                indent(
                    f'msg = page.wait_for_event("console", lambda m: "{patt}" in m.text)',
                    IND,
                )
            )
            out.append(indent(f'assert "{patt}" in msg.text', IND))
            continue

        # ─────────────── hull select / deselect check ────────────────
        if kind == "hull":
            _, action, hull_name = act
            patt = f"{action} hull → {hull_name}"
            out.append(indent("page.wait_for_timeout(100)", IND))
            out.append(indent("assert logs, 'no console logs captured'", IND))
            out.append(indent(f'assert any("{patt}" in t for t in logs)', IND))
            continue
        # ──────── console “Process Error completed” check ────────────
        if kind == "proc_err":
            patt = "Process Error completed"
            # already in backlog?
            out.append(indent(f'if any("{patt}" in t for t in logs):', IND))
            out.append(indent("    pass", IND * 2))
            out.append(indent("else:", IND))
            out.append(
                indent(
                    '    page.wait_for_event("console", '
                    f'lambda m: "{patt}" in m.text, timeout=120_000)',
                    IND,
                )
            )
            out.append(indent(f'assert any("{patt}" in t for t in logs)', IND))
            continue
    return "\n".join(out)


def main() -> None:
    """
    Entry point for the E2E log conversion script.

    Reads a console-based [E2E] log file provided as a command-line argument,
    parses and compresses the interaction events, and prints a generated
    Playwright + pytest test script to stdout.

    Usage:
        python convert_e2e_log.py recording.log

    Exits with an error message if no input file is provided.
    """
    if len(sys.argv) != 2:
        print("usage: convert_e2e_log.py recording.log", file=sys.stderr)
        sys.exit(1)

    lines = Path(sys.argv[1]).read_text().splitlines()
    actions = compress_moves(strip_trailing_copy(list(parse(lines))))
    print(gen_pytest(actions, port=5004))


if __name__ == "__main__":
    main()
